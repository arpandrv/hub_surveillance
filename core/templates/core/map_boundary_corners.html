{% extends 'core/base.html' %}

{% block title %}Map Boundary Corners - {{ farm.name }}{% endblock %}

{% block head_extra %}
{# Add Leaflet CSS #}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<style>
  #map {
    height: 65vh; /* Adjust height */
    width: 100%;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-bottom: 1rem;
  }
  .status-bar {
    padding: 0.5rem 1rem;
    background-color: #e9ecef;
    margin-bottom: 1rem;
    border-radius: 4px;
    font-size: 0.9rem;
  }
  .corner-controls button {
      margin-bottom: 0.5rem;
  }
  .accuracy-circle {
      stroke: rgba(0, 123, 255, 0.3);
      stroke-width: 1;
      fill: rgba(0, 123, 255, 0.1);
  }
</style>
{% endblock head_extra %}

{% block content %}
<div class="container mt-4">
    <div class="card shadow-sm">
        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
            <h4 class="mb-0">Map Farm Boundary Corners</h4>
            <span class="badge bg-light text-dark">{{ farm.name }}</span>
        </div>
        <div class="card-body">

            <div class="alert alert-warning small" role="alert">
                <i class="bi bi-exclamation-triangle me-1"></i>
                <strong>Instructions:</strong> Go to the first corner of your farm boundary. Click "Record Corner". Then, walk around the perimeter to the next corner and click "Record Corner" again. Repeat for all corners, ensuring you record them <strong>strictly in order</strong> (clockwise or counter-clockwise). Click "Save Boundary" when finished. You need at least 3 corners.
            </div>

            <div class="status-bar d-flex justify-content-between align-items-center">
                <div>
                    Current Corner: <span id="corner-number" class="fw-bold">1</span>
                </div>
                <div>
                    Corners Recorded: <span id="point-count" class="fw-bold">0</span>
                </div>
                 <div>
                    GPS Status: <span id="gps-status">Initializing...</span>
                </div>
            </div>

            <div id="map"></div>

            <div class="row corner-controls">
                <div class="col-md-4 mb-2">
                    <button id="record-corner-button" class="btn btn-primary w-100">
                        <i class="bi bi-geo-alt-fill"></i> Record Corner <span id="current-corner-label">1</span>
                    </button>
                </div>
                 <div class="col-md-4 mb-2">
                    <button id="undo-button" class="btn btn-outline-warning w-100" disabled>
                        <i class="bi bi-arrow-counterclockwise"></i> Undo Last Corner
                    </button>
                </div>
                <div class="col-md-4 mb-2">
                    <button id="save-button" class="btn btn-success w-100" disabled>
                        <i class="bi bi-check-lg"></i> Save Boundary
                    </button>
                 </div>
            </div>

            <ul id="coordinate-list" class="list-group list-group-flush small mt-2" style="max-height: 100px; overflow-y: auto;">
                {# Recorded coordinates will be listed here by JS #}
            </ul>

            {# Hidden form to submit data #}
            <form id="boundary-form" method="post" class="mt-3 d-none">
                {% csrf_token %}
                <input type="hidden" name="boundary_coordinates" id="id_boundary_coordinates">
                {# Add farm id if needed, although view will get it from URL #}
            </form>
             <div id="form-messages"></div> {# For success/error messages #}
            
             <hr>
             <div class="text-end">
                 <a href="{% url 'core:farm_detail' farm_id=farm.id %}" class="btn btn-sm btn-outline-secondary">Cancel Mapping</a>
            </div>

        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
{{ block.super }}
{# Add Leaflet JS #}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    console.log("Corner mapping page loaded");

    // --- Map Initialization ---
    // Initialize with a default view, will be updated by geolocation
    const map = L.map('map').setView([0, 0], 2);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // --- UI Elements ---
    const recordButton = document.getElementById('record-corner-button');
    const undoButton = document.getElementById('undo-button');
    const saveButton = document.getElementById('save-button');
    const gpsStatusDisplay = document.getElementById('gps-status');
    const cornerNumberDisplay = document.getElementById('corner-number');
    const cornerLabelDisplay = document.getElementById('current-corner-label');
    const pointCountDisplay = document.getElementById('point-count');
    const coordinateListDisplay = document.getElementById('coordinate-list');
    const boundaryInput = document.getElementById('id_boundary_coordinates');
    const boundaryForm = document.getElementById('boundary-form');
    
    // --- State Variables ---
    let cornerPoints = []; // Array to store recorded boundary corners
    let currentMarker = null; // Marker for current position
    let accuracyCircle = null; // Circle to show GPS accuracy
    let positionWatchId = null; // ID for the watchPosition
    let currentBoundaryLayer = null; // Layer for displaying boundary polygon
    let mapInitialized = false; // Flag to track if map has been centered on user
    
    // --- Utility Functions ---
    function formatCoordinate(lat, lng) {
        return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    }
    
    function updateUI() {
        // Update corner counts
        const nextCornerNum = cornerPoints.length + 1;
        cornerNumberDisplay.textContent = nextCornerNum;
        cornerLabelDisplay.textContent = nextCornerNum;
        pointCountDisplay.textContent = cornerPoints.length;
        
        // Update buttons state
        undoButton.disabled = cornerPoints.length === 0;
        saveButton.disabled = cornerPoints.length < 3;
        
        // Update coordinate list
        coordinateListDisplay.innerHTML = '';
        cornerPoints.forEach((point, index) => {
            const listItem = document.createElement('li');
            listItem.className = 'list-group-item d-flex justify-content-between align-items-center py-1';
            listItem.innerHTML = `
                <span>Corner ${index+1}: ${formatCoordinate(point[0], point[1])}</span>
                <span class="badge bg-secondary">Accuracy: ${point[2]}m</span>
            `;
            coordinateListDisplay.appendChild(listItem);
        });
        
        // Update boundary polygon on map
        drawBoundaryPolygon();
    }
    
    function drawBoundaryPolygon() {
        // Remove existing polygon if any
        if (currentBoundaryLayer) {
            map.removeLayer(currentBoundaryLayer);
        }
        
        // Need at least 3 points for a polygon
        if (cornerPoints.length < 3) {
            return;
        }
        
        // Extract just lat/lng pairs for the polygon (excluding accuracy)
        const polygonPoints = cornerPoints.map(point => [point[0], point[1]]);
        
        // Create a closed polygon (add first point at the end)
        const closedPolygon = [...polygonPoints, polygonPoints[0]];
        
        // Create the polygon and add to map
        currentBoundaryLayer = L.polygon(closedPolygon, {
            color: 'green',
            weight: 3,
            fillColor: 'green',
            fillOpacity: 0.2
        }).addTo(map);
        
        // Fit map to boundary
        map.fitBounds(currentBoundaryLayer.getBounds());
    }
    
    function startPositionWatch() {
        if (!navigator.geolocation) {
            gpsStatusDisplay.textContent = "Geolocation not supported";
            gpsStatusDisplay.style.color = "red";
            return;
        }
        
        gpsStatusDisplay.textContent = "Getting position...";
        gpsStatusDisplay.style.color = "orange";
        
        // Use a one-time getCurrentPosition first for faster initial positioning
        navigator.geolocation.getCurrentPosition(
            updatePosition,
            handlePositionError,
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
        
        // Then start continuous watch with watchPosition
        positionWatchId = navigator.geolocation.watchPosition(
            updatePosition, 
            handlePositionError,
            { 
                enableHighAccuracy: true,
                timeout: 30000,
                maximumAge: 0 // Force fresh readings
            }
        );
    }
    
    function updatePosition(position) {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const accuracy = position.coords.accuracy;
        
        // Log position details
        console.log(`Position update: Lat=${lat.toFixed(6)}, Lng=${lng.toFixed(6)}, Acc=${accuracy.toFixed(1)}m`);
        
        // Update position marker on map
        if (currentMarker) {
            map.removeLayer(currentMarker);
        }
        currentMarker = L.marker([lat, lng], {
            title: 'Current Position'
        }).addTo(map);
        
        // Update accuracy circle
        if (accuracyCircle) {
            map.removeLayer(accuracyCircle);
        }
        accuracyCircle = L.circle([lat, lng], {
            radius: accuracy,
            className: 'accuracy-circle'
        }).addTo(map);
        
        // Update GPS status display
        gpsStatusDisplay.textContent = `Accuracy: ${accuracy.toFixed(1)}m`;
        
        // Color-code accuracy
        if (accuracy <= 10) {
            gpsStatusDisplay.style.color = "green"; // Excellent
        } else if (accuracy <= 30) {
            gpsStatusDisplay.style.color = "#5cb85c"; // Good
        } else if (accuracy <= 100) {
            gpsStatusDisplay.style.color = "orange"; // Fair
        } else {
            gpsStatusDisplay.style.color = "red"; // Poor
        }
        
        // Center map on first position fix
        if (!mapInitialized) {
            map.setView([lat, lng], 18); // Zoom level 18 is good for outdoor mapping
            mapInitialized = true;
        }
    }
    
    function handlePositionError(error) {
        console.error("GPS error:", error);
        gpsStatusDisplay.textContent = `GPS Error: ${error.message}`;
        gpsStatusDisplay.style.color = "red";
        
        // Alert user if permissions denied
        if (error.code === error.PERMISSION_DENIED) {
            alert("Location permission denied. Please enable location services for this site to map boundaries.");
        }
    }
    
    function recordCorner() {
        if (!currentMarker) {
            alert("Waiting for GPS position. Please try again when your position appears on the map.");
            return;
        }
        
        const position = currentMarker.getLatLng();
        const accuracy = accuracyCircle ? accuracyCircle.getRadius() : null;
        
        // Confirm if accuracy is poor
        if (accuracy > 50) {
            if (!confirm(`GPS accuracy is currently ${accuracy.toFixed(1)}m, which is not optimal. Record anyway?`)) {
                return;
            }
        }
        
        // Store the corner coordinates with accuracy information
        cornerPoints.push([position.lat, position.lng, accuracy]);
        
        // Add a numbered marker for this corner
        const cornerNumber = cornerPoints.length;
        L.marker([position.lat, position.lng], {
            icon: L.divIcon({
                html: `<div style="background-color:green; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-weight:bold;">${cornerNumber}</div>`,
                className: 'corner-marker',
                iconSize: [20, 20]
            })
        }).addTo(map);
        
        // Update UI
        updateUI();
    }
    
    function undoLastCorner() {
        if (cornerPoints.length === 0) return;
        
        cornerPoints.pop();
        updateUI();
        // Refresh map to remove the marker (quick way is to redraw all markers)
        map.eachLayer(layer => {
            if (layer instanceof L.Marker && layer !== currentMarker) {
                map.removeLayer(layer);
            }
        });
        
        // Redraw numbered markers for remaining corners
        cornerPoints.forEach((point, index) => {
            L.marker([point[0], point[1]], {
                icon: L.divIcon({
                    html: `<div style="background-color:green; color:white; border-radius:50%; width:20px; height:20px; display:flex; align-items:center; justify-content:center; font-weight:bold;">${index+1}</div>`,
                    className: 'corner-marker',
                    iconSize: [20, 20]
                })
            }).addTo(map);
        });
    }
    
    function saveBoundary() {
        if (cornerPoints.length < 3) {
            alert("You need at least 3 corner points to create a boundary.");
            return;
        }
        
        // Create GeoJSON Polygon structure
        // Ensure the polygon is closed by adding the first point at the end
        const coordinates = cornerPoints.map(point => [point[1], point[0]]); // GeoJSON uses [lng, lat] order
        coordinates.push(coordinates[0]); // Close the polygon
        
        const geoJSON = {
            type: "Polygon",
            coordinates: [coordinates]
        };
        
        // Update hidden form field with JSON string
        boundaryInput.value = JSON.stringify(geoJSON);
        
        // Submit the form
        boundaryForm.submit();
    }
    
    // --- Event Listeners ---
    recordButton.addEventListener('click', recordCorner);
    undoButton.addEventListener('click', undoLastCorner);
    saveButton.addEventListener('click', saveBoundary);
    
    // --- Initialize Mapping ---
    // Start position watching when the page loads
    startPositionWatch();
});
</script>
{% endblock extra_js %}